"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndExtract = exports.isRunningInAwsLambdaNode20 = exports.isRunningInAwsLambda = exports.isValidUrl = exports.setupLambdaEnvironment = void 0;
const node_fs_1 = require("node:fs");
const follow_redirects_1 = require("follow-redirects");
const node_os_1 = require("node:os");
const tar_fs_1 = require("tar-fs");
/**
 * Adds the proper folders to the environment
 * @param baseLibPath the path to this packages lib folder
 */
const setupLambdaEnvironment = (baseLibPath) => {
    // If the FONTCONFIG_PATH is not set, set it to /tmp/fonts
    process.env["FONTCONFIG_PATH"] ??= "/tmp/fonts";
    // If LD_LIBRARY_PATH is undefined, set it to baseLibPath, otherwise, add it
    if (process.env["LD_LIBRARY_PATH"] === undefined) {
        process.env["LD_LIBRARY_PATH"] = baseLibPath;
    }
    else if (process.env["LD_LIBRARY_PATH"].startsWith(baseLibPath) !== true) {
        process.env["LD_LIBRARY_PATH"] = [
            baseLibPath,
            ...new Set(process.env["LD_LIBRARY_PATH"].split(":")),
        ].join(":");
    }
};
exports.setupLambdaEnvironment = setupLambdaEnvironment;
/**
 * Determines if the input is a valid URL
 * @param input the input to check
 * @returns boolean indicating if the input is a valid URL
 */
const isValidUrl = (input) => {
    try {
        return !!new URL(input);
    }
    catch {
        return false;
    }
};
exports.isValidUrl = isValidUrl;
/**
 * Determines if the running instance is inside an AWS Lambda container,
 * and the nodejs version is less than v20. This is to target AL2 instances
 * AWS_EXECUTION_ENV is for native Lambda instances
 * AWS_LAMBDA_JS_RUNTIME is for netlify instances
 * VERCEL for Vercel Functions (Node 18 enables an AL2-compatible environment)
 * @returns boolean indicating if the running instance is inside a Lambda container
 */
const isRunningInAwsLambda = (nodeMajorVersion) => {
    if (process.env["AWS_EXECUTION_ENV"] &&
        process.env["AWS_EXECUTION_ENV"].includes("AWS_Lambda_nodejs") &&
        !process.env["AWS_EXECUTION_ENV"].includes("20.x") &&
        !process.env["AWS_EXECUTION_ENV"].includes("22.x")) {
        return true;
    }
    else if (process.env["AWS_LAMBDA_JS_RUNTIME"] &&
        process.env["AWS_LAMBDA_JS_RUNTIME"].includes("nodejs") &&
        !process.env["AWS_LAMBDA_JS_RUNTIME"].includes("20.x") &&
        !process.env["AWS_LAMBDA_JS_RUNTIME"].includes("22.x")) {
        return true;
    }
    else if (process.env["VERCEL"] && nodeMajorVersion == 18) {
        return true;
    }
    return false;
};
exports.isRunningInAwsLambda = isRunningInAwsLambda;
/**
 * Determines if the running instance is inside an AWS Lambda container,
 * and the nodejs version is 20. This is to target AL2023 instances
 * AWS_EXECUTION_ENV is for native Lambda instances
 * AWS_LAMBDA_JS_RUNTIME is for netlify instances
 * CODEBUILD_BUILD_IMAGE is for CodeBuild instances
 * VERCEL is for Vercel Functions (Node 20 or later enables an AL2023-compatible environment).
 * @returns boolean indicating if the running instance is inside a Lambda container with nodejs20
 */
const isRunningInAwsLambdaNode20 = (nodeMajorVersion) => {
    if ((process.env["AWS_EXECUTION_ENV"] &&
        process.env["AWS_EXECUTION_ENV"].includes("20.x")) ||
        (process.env["AWS_EXECUTION_ENV"] &&
            process.env["AWS_EXECUTION_ENV"].includes("22.x")) ||
        (process.env["AWS_LAMBDA_JS_RUNTIME"] &&
            process.env["AWS_LAMBDA_JS_RUNTIME"].includes("20.x")) ||
        (process.env["AWS_LAMBDA_JS_RUNTIME"] &&
            process.env["AWS_LAMBDA_JS_RUNTIME"].includes("22.x")) ||
        (process.env["CODEBUILD_BUILD_IMAGE"] &&
            process.env["CODEBUILD_BUILD_IMAGE"].includes("nodejs20")) ||
        (process.env["CODEBUILD_BUILD_IMAGE"] &&
            process.env["CODEBUILD_BUILD_IMAGE"].includes("nodejs22")) ||
        (process.env["VERCEL"] && nodeMajorVersion >= 20)) {
        return true;
    }
    return false;
};
exports.isRunningInAwsLambdaNode20 = isRunningInAwsLambdaNode20;
const downloadAndExtract = async (url) => new Promise((resolve, reject) => {
    const getOptions = new URL(url);
    getOptions.maxBodyLength = 60 * 1024 * 1024; // 60mb
    const destDir = `${(0, node_os_1.tmpdir)()}/chromium-pack`;
    const extractObj = (0, tar_fs_1.extract)(destDir);
    follow_redirects_1.https
        .get(url, (response) => {
        response.pipe(extractObj);
        extractObj.on("finish", () => {
            resolve(destDir);
        });
    })
        .on("error", (err) => {
        (0, node_fs_1.unlink)(destDir, (_) => {
            reject(err);
        });
    });
});
exports.downloadAndExtract = downloadAndExtract;
